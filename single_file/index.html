<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./style.css">
    <title>CPU scheduling with separate I/O</title>
</head>

<body>
    <style>
        :root {
            /* color */
            --primary-color: #3f51b5;
            --secondary-color: #f44336;
            --accent-color: #F5F1DE;
            --white: #ffffff;
            --black: #000000;
            --danger: #dc3545;
            --light-danger: #f8d7da;
            --orange: #ff7100;
            --red: #FF0000;
            --blue: #00B0F0;
            --green: #92D050;
            --light-grey: #dddddd;
            --grey: #C6C6C6;
            --highlight: dodgerblue;
            /* border */
            --empty-border: 2px dashed var(--black);
        }

        html,
        .box {
            scroll-behavior: smooth;
        }

        body {
            margin: 0px;
        }

        /* background color */

        .bg-red {
            background-color: var(--red);
        }

        .bg-orange {
            background-color: var(--orange);
        }

        .bg-green {
            background-color: var(--green);
        }

        .bg-blue {
            background-color: var(--blue);
        }

        /* text color */

        .text-white {
            color: var(--white);
        }

        /* border right */

        .border-solid-right-highlight {
            border-right: 2px solid var(--highlight);
        }

        /* border bottom */

        .border-dashes-bottom-blue {
            border-bottom: 2px dashed var(--blue);
        }

        .border-dashes-bottom-red {
            border-bottom: 2px dashed var(--red);
        }

        .border-dashes-bottom-green {
            border-bottom: 2px dashed var(--green);
        }

        .border-dashes-bottom-orange {
            border-bottom: 2px dashed var(--orange);
        }

        /* border left */

        .border-dashes-left-blue {
            border-left: 2px dashed var(--blue);
        }

        .border-dashes-left-red {
            border-left: 2px dashed var(--red);
        }

        .border-dashes-left-green {
            border-left: 2px dashed var(--green);
        }

        .border-dashes-left-orange {
            border-left: 2px dashed var(--orange);
        }

        /* style button */

        button {
            background-color: #4CAF50;
            /* Green */
            border: none;
            color: white;
            padding: 10px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 12px;
            margin: 4px 2px;
            cursor: pointer;
        }

        .control-bar button:disabled {
            background-color: var(--grey) !important;
            color: var(--white) !important;
            border: none !important;
        }

        button#reset-btn {
            background-color: var(--white);
            color: var(--black);
            border: 1px solid var(--black);
        }

        button:hover,
        button#reset-btn:hover {
            transition: all .2s;
            background-color: var(--black);
            color: var(--white)
        }

        #app-bar #title {
            margin: 0;
            background-color: var(--primary-color);
            color: var(--white);
            padding: 30px;
        }

        /* CONTENT */

        .container,
        .row {
            display: flex;
        }

        .container {
            flex-direction: column;
        }

        .box {
            overflow-x: auto;
            background-color: var(--accent-color);
            border: 1px solid var(--black);
            margin: 50px 200px;
            margin-bottom: 0;
            padding: 50px;
        }

        @media only screen and (max-width: 1300px) {
            .box {
                background-color: var(--accent-color);
                margin: 50px 50px;
                padding: 50px 50px;
            }
        }

        #content-wrapper {
            padding-bottom: 50px;
        }

        #content-wrapper .row {
            flex-direction: row;
        }

        table {
            border-collapse: collapse;
        }

        /* result table */

        div#result-box {
            display: block;
        }

        table#result-table {
            border-spacing: 0px;
            width: 100%;
        }

        table#result-table .level-name-cell {
            text-align: left;
        }

        table#result-table td {
            height: 30px;
        }

        table#result-table thead th {
            text-align: left;
        }

        table#result-table .process-label {
            color: var(--white);
        }

        table#result-table tbody td:nth-child(odd) {
            /*background-color: dodgerblue;*/
        }

        table#result-table th.level-thead,
        table#result-table th.process-thead {
            width: 150px;
        }

        table#result-table td {}

        /* data table */

        form#main-form {
            display: flex;
            flex-direction: column;
        }

        .form-table {
            max-width: 100%;
            border-collapse: collapse;
        }

        td.process-name,
        th {
            padding: 5px;
        }

        .form-table td,
        .form-table th {
            min-width: 30px;
            border: 1px solid var(--black);
            text-align: center;
        }

        .form-table .process-name {
            text-align: left;
        }

        .form-table input {
            width: 50px;
            height: 20px;
            text-align: center;
        }

        /* statistic table */

        table#statistic-table {
            width: 300px;
            background-color: var(--white);
        }

        @media only screen and (max-width: 350px) {
            table#statistic-table {
                width: 100%;
            }
        }

        table#statistic-table tr:nth-child(even) {
            background-color: #dddddd;
        }

        table#statistic-table tbody tr:last-child {
            background-color: dodgerblue;
            color: var(--white);
            font-weight: bold;
        }

        table#statistic-table td,
        table#statistic-table th {
            border: 1px solid var(--light-grey)
        }

        table#statistic-table td:first-child {
            font-weight: bold;
        }

        table#statistic-table td:not(:first-child) {
            text-align: right;
        }

        table#statistic-table td {
            padding-left: 5px;
            padding-right: 5px;
        }

        /* control bar */

        .control-bar {
            margin-bottom: 20px;
            display: flex;
            align-items: flex-start;
        }

        .control-bar button {
            margin-right: 20px;
        }

        /* responsive */

        @media only screen and (max-width: 800px) {
            .control-bar {
                flex-direction: column;
            }

            .control-bar button {
                min-width: 160px;
            }

            .box {
                padding: 10px;
                margin: 0px;
            }
        }

        /* option  bar */

        .option-bar {
            display: flex;
            margin: 10px 0;
        }

        .option-bar div {
            margin-right: 30px;
        }

        input#quantum-input {
            width: 50px;
            text-align: center;
        }

        #quantum-container {
            display: none;
        }

        #ready-queue tr {
            height: 30px;
        }

        .tr-spacing td {
            border-top: 1px solid var(--black);
        }

        .level-column-empty {
            border-left: 1px dashed var(--black);
            border-right: 1px dashed var(--black);
        }

        .left-dashes-border {
            border-left: var(--empty-border);
        }

        .right-dashes-border {
            border-right: var(--empty-border);
        }

        .vertical-dashes-border {
            border-left: var(--empty-border);
            border-right: var(--empty-border);
        }

        /* error message */

        p#error-message-area:empty {
            height: 0px;
            padding: 0px;
            margin: 0px;
        }

        p#error-message-area {
            color: var(--danger);
            background-color: var(--light-danger);
            display: flex;
            align-items: center;
            padding-left: 30px;
        }

        /* rendering mode */

        #rendering-mode-container {
            display: flex;
            margin-top: 10px;
        }

        #rendering-mode-container>span {
            margin-right: 20px;
        }

        .radio-button-container {
            display: flex;
        }

        input[type="radio"]:checked+label {
            color: dodgerblue;
            font-weight: bold;
        }
    </style>
    <div class="wrapper">
        <!-- APP BAR -->
        <div id="app-bar">
            <h2 id="title">CPU scheduling with separate I/O</h2>
        </div>

        <!-- MAIN CONTENT -->
        <div id="content-wrapper" class="container">
            <div class="box">
                <form id="input-table-form">
                    <!-- ERROR MESSAGE -->
                    <p id="error-message-area"></p>

                    <!-- CONTROL BAR -->
                    <div class="control-bar">
                        <button type="button" id="add-process-btn">Add new process</button>
                        <button type="button" id="add-request-btn">Add request</button>
                        <button type="button" id="reset-btn">Reset</button>
                        <button type="run-btn" id="run-btn">Run</button>
                    </div>

                    <!-- OPTION BAR -->
                    <div class="option-bar">
                        <!-- ALGORITHM -->
                        <div>
                            <span>Algorithm</span>
                            <select id="algorithm-select">
                                <option selected value="fcfs">FCFS</option>
                                <option value="sjf">SJF</option>
                                <option value="srtf">SRTF</option>
                                <option value="rr">Round Robin</option>
                            </select>
                        </div>

                        <!-- OPTIONAL -->
                        <div id="quantum-container">
                            <span>Quantum</span>
                            <input id="quantum-input" type="number" min="1" value="2">
                        </div>
                    </div>

                    <!-- TABLE -->
                    <div id="form-table-area">
                        <!-- TABLE WILL BE RENDERED BY JAVASCRIPT-->
                    </div>
                </form>
                <form id="option-form">
                    <div id="rendering-mode-container">
                        <span>Rendering mode</span>
                        <div class="radio-button-container">
                            <div>
                                <input type="radio" name="rendering-mode" value="immediate" id="immediate">
                                <label for="immediate">Immediate</label><br>
                            </div>
                            <div>
                                <input type="radio" name="rendering-mode" value="playing" id="playing">
                                <label for="playing">Playing</label><br>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
            <div id="result-box" class="box">
                <h2 id="algorithm-heading"></h2>

                <div id="result-table-area">
                    <!-- TABLE WILL BE RENDERED BY JAVASCRIPT-->
                </div>

                <div id="statistic-table-area">
                    <!-- TABLE WILL BE RENDERED BY JAVASCRIPT-->
                </div>
            </div>
        </div>
    </div>
    <script>
        // DEFINE OBJECTS
        function ProcessList(list) {
            this.list = list;

            this.add = function (process) {
                this.list.push(process);
            }

            this.addNewProcess = function () {
                let process1 = this.list[0];
                let cpus = process1.cpus.map(item => 0);
                let ios = cpus.slice(0, cpus.length - 1);
                let process = new Process(`p${this.list.length + 1}`, this.getLastArrivalTime() + 1, cpus, ios);
                this.add(process);
            }

            this.addNewRequest = function () {
                this.list.forEach(item => {
                    item.addNewRequest();
                })
            }

            this.clone = function () {
                let plainObject = JSON.parse(JSON.stringify(this));
                let processes = plainObject.list.map(p => {
                    return new Process(p.name, p.arrival, p.cpus, p.ios, p.cpuRequests);
                })
                let processList = new ProcessList(processes);
                return processList;
            }

            this.getProcessByArrival = function (time) {
                return this.list.filter(item => {
                    return item.arrival == time;
                })
            }

            this.getProcessByName = function (name) {
                return this.list.filter(item => item.name == name)[0];
            }

            this.calculationTimes = function (cpuBox) {
                this.list.forEach(process => process.calculateTimes(cpuBox))
                this.calculateAverageTimes();
            }

            this.calculateAverageTimes = function () {
                let totalProcess = this.list.length;
                let totalResponseTime = 0;
                let totalWaitingTime = 0;
                let totalTurnAroundTime = 0;
                this.list.forEach(p => {
                    totalResponseTime += p.responseTime;
                    totalWaitingTime += p.waitingTime;
                    totalTurnAroundTime += p.turnAroundTime;
                })
                this.avgResponseTime = totalResponseTime / totalProcess;
                this.avgWaitingTime = totalWaitingTime / totalProcess;
                this.avgTurnAroundTime = totalTurnAroundTime / totalProcess;
            }

            this.getError = function () {
                let err = null;
                for (let p of this.list) {
                    const lastNonZeroCpuIndex = this.getLastNonZeroValIndex(p.cpus);
                    const lastNonZeroIoIndex = this.getLastNonZeroValIndex(p.ios);

                    // 1. cpus[0], cpus[1], ios[0] > 0
                    if (lastNonZeroCpuIndex < 1) {
                        err = `Process "${p.name}" values required`;
                        break;
                    }

                    // 2. end cpu
                    if (lastNonZeroCpuIndex <= lastNonZeroIoIndex) {
                        err = `Process "${p.name}" must end with cpu`;
                        break;
                    }

                    // 3. no 0 between
                    if (lastNonZeroCpuIndex - lastNonZeroIoIndex > 1 || this.isZeroValueInTheMiddle(p.cpus, p.ios, lastNonZeroIoIndex + 1)) {
                        err = `Process "${p.name}" must not have empty value in the middle`;
                        break;
                    }

                    // 4. unique arrival
                    const arrivalCountObj = {};
                    const arrivals = this.list.map(p => p.arrival);
                    arrivals.forEach(item => {
                        if (!arrivalCountObj[item]) arrivalCountObj[item] = 1;
                        else arrivalCountObj[item]++;
                    })
                    for (let key in arrivalCountObj)
                        if (arrivalCountObj[key] > 1) {
                            err = `Arrival of process must unique`;
                            break;
                        }
                }
                return err;
            }

            this.isZeroValueInTheMiddle = function (arr1, arr2, n) {
                for (let i = 0; i < n; i++) {
                    if (arr1[i] == 0 || arr2[i] == 0) return true;
                }
                return false;
            }

            this.getLastNonZeroValIndex = function (arr) {
                for (let i = arr.length - 1; i >= 0; i--) {
                    if (arr[i] != 0) return i;
                }
                return -1;
            }

            this.getLastArrivalTime = function () {
                let max = 0;
                this.list.forEach(p => {
                    if (p.arrival > max)
                        max = p.arrival;
                })
                return max;
            }
        }

        function Process(name, arrival, cpus, ios, cpuRequests = null) {
            this.name = name;
            this.arrival = Number.parseInt(arrival);
            this.cpuRequests = cpuRequests || [arrival];

            this.cpus = cpus.map(val => {
                let n = Number.parseInt(val);
                return Number.isNaN(n) ? 0 : n;
            });
            this.ios = ios.map(val => {
                let n = Number.parseInt(val);
                return Number.isNaN(n) ? 0 : n;
            });

            // ADD REQUEST
            this.addNewRequest = function () {
                this.cpus.push(0);
                this.ios.push(0);
            }

            // CALCULATE TIMES
            this.calculateTimes = function (cpuBox) {
                this.cpuRequestHistories = this.getCpuRequestHistories(cpuBox);
                this.waitingTime = this.getProcessWaitingTime();
                this.responseTime = this.cpuRequestHistories[0][1] - this.cpuRequestHistories[0][0];
                this.turnAroundTime = this.getProcessTurnAroundTime(cpuBox);
            }

            this.getCpuRequestHistories = function (cpuBox) {
                return this.cpuRequests.map(request => {
                    const grantedTime = this.getFirstGrantedCpuTimeOfProcess(cpuBox, request);
                    return [request, grantedTime];
                })
            }

            this.getProcessWaitingTime = function () {
                return this.cpuRequestHistories.reduce((prev, current) => {
                    return prev + (current[1] - current[0]);
                }, 0);
            }

            this.getProcessTurnAroundTime = function (cpuBox) {
                const endCpuTime = this.getEndCpuTimeOfProcess(cpuBox);
                const firstGranted = this.getFirstGrantedCpuTimeOfProcess(cpuBox);
                return endCpuTime - firstGranted + this.responseTime + 1;
            }

            this.getFirstGrantedCpuTimeOfProcess = function (cpuBox, start = 0) {
                let index = -1;
                for (let i = start; i < cpuBox.length; i++) {
                    if (cpuBox[i] == this.name) {
                        index = i
                        break;
                    }
                }
                return index;
            }

            this.getEndCpuTimeOfProcess = function (cpuBox) {
                let index = -1;
                for (let key = cpuBox.length - 1; key >= 0; key--) {
                    if (cpuBox[key] == this.name) {
                        index = key
                        break;
                    }
                }
                return index;
            }

        }

    </script>
    <script>
        class Algorithm {
            maxCpuVal = 999999;
            maxTime = 1000;

            algorithmName = null;
            quantum = -1;

            // input process list
            pList = null;

            // working process list
            currentPList = null;

            // current cpu holding process
            currentP = null;

            // contain processes back from io
            tempQueue = [];

            // array of time
            timeline = [];

            // initiate boxes
            cpuBox = [];
            ioBox = [];
            readyQueue = [];

            // counter
            ioRemainingObj = {};
            cpuRemainingTime = -1;
            quantumCounter = -1;


            constructor(pList, algorithmName, quantum = 2) {
                this.pList = pList;
                this.currentPList = this.pList.clone();

                // array of time
                this.timeline = this.getTimeline()

                // initiate boxes
                this.cpuBox = this.timeline.map(x => null);
                this.ioBox = this.timeline.map(x => []);

                // counter
                this.ioRemainingObj = this.initiateIoRemainingObj();

                //
                this.algorithmName = algorithmName;
                this.quantum = quantum;
            }

            // RUN ALGORITHM
            run() {
                // loop timeline
                this.timeline.forEach(time => {
                    // ready queue
                    this.solveReadyQueue(time)
                    const checkSpecialConditionOfAlgorithm = this.checkSpecialConditionOfAlgorithm(this.readyQueue[time]);
                    if (this.cpuRemainingTime > 0 && checkSpecialConditionOfAlgorithm) this.cpuBox[time] = this.currentP.name;
                    else {

                        // choose algorithm to run
                        switch (this.algorithmName) {
                            case 'fcfs':
                                this.fcfs(time);
                                break;
                            case 'sjf':
                                this.sjf(time);
                                break;
                            case 'srtf':
                                this.srtf(time)
                                break;
                            case 'rr':
                                this.roundRobin(time)
                                break;
                        }
                    }
                    this.solveIoBox(time)

                    // decrease cpu, quantum counter
                    if (this.cpuRemainingTime > 0) this.cpuRemainingTime--;
                    if (this.quantumCounter > 0) this.quantumCounter--;

                    //this.logDataAtTimePoint(time);
                })
                const lastCpuTime = this.getLastCpuTime();
                this.cpuBox.splice(lastCpuTime + 1);
                this.ioBox.splice(lastCpuTime + 1);
                this.readyQueue.splice(lastCpuTime + 1);

                // re assign process cpus and ios from processList
                this.currentPList.list.forEach(p => {
                    const tempP = this.pList.getProcessByName(p.name);
                    p.cpus = [...tempP.cpus];
                    p.ios = [...tempP.ios];
                })

                this.currentPList.calculationTimes(this.cpuBox);

                // LOG DATA
                this.logFinalData();
                return [this.currentPList, this.cpuBox, this.ioBox, this.readyQueue];
            }

            // 4 ALGORITHMS
            fcfs(time) {
                // grant io for current process
                if (this.isGrantIo()) this.grantIo();

                if (this.readyQueue[time][0]) {
                    // grant cpu for the top process of ready queue
                    const pName = this.readyQueue[time].shift();
                    this.currentP = this.currentPList.getProcessByName(pName);
                    this.cpuBox[time] = this.currentP.name;
                    this.cpuRemainingTime = this.currentP.cpus.shift();
                }
            }

            sjf(time) {
                // grant io for current process
                if (this.isGrantIo()) this.grantIo();

                if (this.readyQueue[time][0]) {
                    // grant cpu for min cpu process
                    const [pName] = this.readyQueue[time].splice(this.getMinCpuProcessIndexInReadyQueue(this.readyQueue[time]), 1);
                    this.currentP = this.currentPList.getProcessByName(pName);
                    this.cpuBox[time] = this.currentP.name;
                    this.cpuRemainingTime = this.currentP.cpus.shift();
                }
            }

            srtf(time) {
                // grant io for current process
                if (this.isGrantIo()) this.grantIo();

                const grantCpu = () => {
                    if (this.readyQueue[time][0]) {
                        // find min cpu process name
                        const [pName] = this.readyQueue[time].splice(this.getMinCpuProcessIndexInReadyQueue(this.readyQueue[time]), 1);
                        this.currentP = this.currentPList.getProcessByName(pName);
                        this.cpuBox[time] = this.currentP.name;
                        this.cpuRemainingTime = this.currentP.cpus.shift();
                    }
                }

                if (this.cpuRemainingTime > 0) {
                    const rest = this.cpuRemainingTime;
                    this.currentP.cpus.unshift(rest);
                    this.readyQueue[time].push(this.currentP.name);
                    grantCpu();
                } else {
                    grantCpu();

                }
            }

            roundRobin(time) {
                // grant io for current process 
                // when time = 0 => currentProcess = null => not grant IO 
                if (this.isGrantIo()) this.grantIo();

                // grant cpu for the top process of ready queue
                const grantCpuForTopProcess = () => {
                    if (this.readyQueue[time][0]) {
                        const pName = this.readyQueue[time].shift();
                        this.currentP = this.currentPList.getProcessByName(pName);
                        this.cpuBox[time] = this.currentP.name;
                        this.cpuRemainingTime = this.currentP.cpus.shift();
                        this.quantumCounter = this.quantum;
                    }
                }

                if (this.cpuRemainingTime > 0) {
                    const rest = this.cpuRemainingTime;
                    this.currentP.cpus.unshift(rest);
                    this.currentP.cpuRequests.push(time);
                    this.readyQueue[time].push(this.currentP.name);
                    grantCpuForTopProcess();
                } else grantCpuForTopProcess();
            }

            isGrantIo() {
                return (this.ioRemainingObj[this.currentP?.name] == -1 && this.cpuRemainingTime == 0 && this.currentP?.ios?.length > 0)
            }
            // 

            checkSpecialConditionOfAlgorithm(readyQueueAtTime) {
                let roundRobin = (this.algorithmName != 'rr' || this.quantumCounter > 0);
                let minCpuProcess = this.getMinCpuProcessInReadyQueue(readyQueueAtTime, this.currentPList);
                let srtf = (this.algorithmName != 'srtf' || this.cpuRemainingTime <= minCpuProcess?.cpus[0]);
                return (roundRobin && srtf);
            }


            getMinCpuProcessInReadyQueue(readyQueueAtTime) {
                let minProcess = null;
                let minCpuVal = this.maxCpuVal;
                readyQueueAtTime.forEach((pName, index) => {
                    let process = this.currentPList.getProcessByName(pName);
                    if (process.cpus[0] < minCpuVal) {
                        minProcess = process;
                        minCpuVal = process.cpus[0];
                    }
                })
                return minProcess;

            }

            getMinCpuProcessIndexInReadyQueue(readyQueueAtTime,) {
                let minCpuVal = this.maxCpuVal;
                let minCpuProcessIndex = 0;
                readyQueueAtTime.forEach((pName, index) => {
                    let process = this.currentPList.getProcessByName(pName);
                    if (process.cpus[0] < minCpuVal) {
                        minCpuVal = process.cpus[0];
                        minCpuProcessIndex = index;
                    }
                })
                return minCpuProcessIndex;

            }

            // ALGORITHM FUNCTIONS
            grantIo() {
                this.ioRemainingObj[this.currentP.name] = this.currentP.ios.shift() - 1;
            }

            solveIoBox(time) {
                for (let key in this.ioRemainingObj) {
                    if (this.ioRemainingObj[key] > -1) {
                        // add process to io box
                        this.ioBox[time].push(key);

                        // if done io => push the process to the end of ready queue
                        if (this.ioRemainingObj[key] == 0) {
                            let tempP = this.currentPList.getProcessByName(key);

                            // save time process request cpu for calculating times later
                            tempP.cpuRequests.push(time + 1);

                            // "tempQueue" will be added to the end of ready queue at the next loop 
                            this.tempQueue.push(key);
                        }

                        // decrease io counter of process
                        this.ioRemainingObj[key]--;
                    }
                }
            }

            solveReadyQueue(time) {
                const arrivalProcess = this.currentPList.getProcessByArrival(time)[0];

                // clone previous ready queue 
                this.readyQueue[time] = [...this.readyQueue[time - 1] || [],];

                // add arrival process at the end of ready queue
                if (arrivalProcess) this.readyQueue[time].push(arrivalProcess.name);

                if (this.tempQueue.length > 0) {
                    // add processes back from io at the end of ready queue
                    this.readyQueue[time] = [...this.readyQueue[time], ...this.tempQueue];

                    // clear tempQueue
                    this.tempQueue.splice(0, this.tempQueue.length);
                }
            }

            initiateIoRemainingObj() {
                const result = {};
                this.currentPList.list.forEach(p => {
                    result[p.name] = -1;
                })
                return result;
            }

            getLastCpuTime() {
                let counter = 0;
                for (let i = this.cpuBox.length - 1; i >= 0; i--) {
                    if (this.cpuBox[i] != null) {
                        counter = i;
                        break;
                    }
                }
                return counter;
            }

            // SUPPORT FUNCTIONS
            getTimeline() {
                let timeline = [];
                for (let i = 0; i < this.maxTime; i++) timeline.push(i);
                return timeline;
            }

            // LOG
            logDataAtTimePoint(time) {
                console.log(`\n${time} ===========`);
                console.log('CPU\t\t', this.cpuBox[time]);
                console.log('IO\t\t', [...this.ioBox[time]]);
                console.log('QUEUE\t', [...this.readyQueue[time]]);
            }

            logFinalData() {
                console.log('\n--');
                console.log('CPU BOX\t\t\t', this.cpuBox);
                console.log('IO BOX\t\t\t', this.ioBox);
                console.log('QUEUE BOX\t\t', this.readyQueue);
                console.log('PROCESS LIST\t', this.currentPList);
            }
        }
    </script>
    <script>
        // HTML DOM ELM
        const domEle = {
            // form
            quantumContainer: document.getElementById('quantum-container'),
            algorithmSelect: document.getElementById('algorithm-select'),
            quantumInput: document.getElementById('quantum-input'),
            inputTableForm: document.getElementById('input-table-form'),
            optionForm: document.getElementById('option-form'),


            // box
            resultBox: document.querySelector('.box:last-child'),

            // table
            formTableInputs: () => document.querySelectorAll('.table-input'),

            // buttons
            addProcessBtn: document.getElementById('add-process-btn'),
            requestBtn: document.getElementById('add-request-btn'),
            resetBtn: document.getElementById('reset-btn'),
            controlBarButtons: document.querySelectorAll('.control-bar button'),

            // area
            resultTableArea: document.getElementById('result-table-area'),
            statisticTableArea: document.getElementById('statistic-table-area'),
            errorMessageArea: document.getElementById('error-message-area'),
            formTableArea: document.getElementById('form-table-area'),

            // heading
            algorithmHeading: document.getElementById('algorithm-heading'),

        }

        // DEFINE OBJECTS
        class Data {
            static colors = ['blue', 'green', 'red', 'orange',];

            static renderResultMode = {
                immediate: 'immediate',
                playing: 'playing',
            }

            constructor() {
                const lectureData = [
                    new Process('p1', 0, [3, 4], [4]),
                    new Process('p2', 1, [2, 2], [2]),
                    new Process('p3', 2, [1, 3], [1]),
                ];

                const exerciseData = [
                    new Process('p1', 0, [1, 1, 1, 1, 1], [4, 4, 4, 4]),
                    new Process('p2', 1, [2, 2, 3, 0, 0], [7, 7, 0, 0]),
                    new Process('p3', 2, [13, 2, 0, 0, 0], [6, 0, 0, 0]),
                ];
                this.defaultProcessArr = exerciseData;
            }
        }

        class FormTable {
            pList = [];

            render(pList) {
                this.pList = pList;
                domEle.formTableArea.innerHTML = this.getTableHtml();
                this.setupTableEvents();

            }

            setupTableEvents() {
                domEle.formTableInputs().forEach(input => {
                    input.addEventListener('change', () => {
                        this.loadProcessListFromTable();
                    })
                })
            }


            getTableHtml() {
                let tableHtml = `<table table class="form-table" > ${this.getFormTableTHeadHtml()} ${this.getFormTableTBodyHtml()}</table > `;
                return tableHtml;
            }

            getFormTableTHeadHtml() {
                let htmlStr = '';
                let process1 = this.pList.list[0];
                for (let i = 0; i < process1.ios.length; i++) {
                    htmlStr += `<th>IO</th><th>CPU</th>`;
                }

                let tHead = `
        <thead thead >
            <tr>
                <th scope="col">#</th>
                <th>Process</th>
                <th>Arrival</th>
                <th>CPU</th>
                ${htmlStr}
            </tr>
        </thead>`;
                return tHead;

            }

            getFormTableTBodyHtml() {
                let rows = '';
                this.pList.list.forEach((item, index) => {
                    let htmlStr = ` 
            <th scope="row">${index + 1}</th>
            <td class="process-name">${item.name}</td>`;
                    htmlStr += this.getNumberInputHtml(`arrival - ${index} `, item.arrival, 0) + this.getCpuAndIoColumn(item, index);
                    rows += `<tr> ${htmlStr}</tr> `;
                })

                let tBody = ` <tbody> ${rows}</tbody>`;
                return tBody;
            }

            getCpuAndIoColumn(item, index) {
                let str = ''
                item.cpus.forEach((cpuVal, cpuIndex) => {
                    cpuVal = cpuVal || '';
                    str += this.getNumberInputHtml(`cpu - ${index} -${cpuIndex} `, cpuVal);
                    if (cpuIndex < item.cpus.length - 1) {
                        let ioVal = item.ios[cpuIndex] || '';
                        str += this.getNumberInputHtml(`io - ${index} -${cpuIndex} `, ioVal);
                    }
                })
                return str;
            }

            getNumberInputHtml(name, value, min = 1) {
                return `<td>
                <input class="table-input" name="${name}" value="${value}" type="number" min="${min}" max="100" step="1"/>
            </td> `;
            }

            loadProcessListFromTable() {
                const formData = new FormData(domEle.inputTableForm)
                const arrivalIndexArr = [];
                let i = 0;

                for (let item of formData.keys()) {
                    if (item.includes('arrival')) arrivalIndexArr.push(i);
                    i++;
                }
                const entries = [];
                for (let item of formData.entries()) {
                    entries.push(item);
                }
                //
                let step = arrivalIndexArr[1] - arrivalIndexArr[0];
                let processes = arrivalIndexArr.map((val, index) => {
                    let data = entries.slice(val, val + step);
                    let arrival = (data.length > 0) ? data[0][1] : 0;
                    let cpus = [];
                    let ios = [];
                    data.slice(1).forEach(item => {
                        if (item[0].indexOf('cpu') > -1) cpus.push(item[1]);
                        else ios.push(item[1]);
                    })
                    return new Process(`p${index + 1}`, arrival, cpus, ios);
                })
                this.pList.list = processes;
            }
        }

        class ResultBox {
            static renderingMode = Data.renderResultMode.immediate
            static renderingGapTime = 200;

            algorithmName = null;
            timelineLength = 0;
            resultTableMaxTime = 0;
            renderResultTableInterval = null;
            quantum = -1;

            resultTable = new ResultTable();
            statisticTable = new StatisticTable();

            constructor() {
            }

            render(resultProcessList, cpuBox, ioBox, readyQueue, algorithmName, quantum) {
                ResultBox.clearTables();
                this.algorithmName = algorithmName;
                this.quantum = quantum;
                // display result box
                this.timelineLength = cpuBox.length;
                domEle.resultBox.scrollLeft = 0;
                // algorithm name
                let algorithmHeadingVal = (this.algorithmName == 'rr') ? `${this.algorithmName.toUpperCase()} Algorithm (q=${this.quantum})` : `${this.algorithmName.toUpperCase()} Algorithm`;
                domEle.algorithmHeading.innerText = algorithmHeadingVal;

                if (ResultBox.renderingMode == Data.renderResultMode.immediate) this.renderResultImmediateMode(resultProcessList, cpuBox, ioBox, readyQueue);
                else this.renderResultPlayingMode(resultProcessList, cpuBox, ioBox, readyQueue);

                // display result box
                domEle.resultBox.style.display = 'block';
                Helper.scrollToBottom();
            }

            renderResultImmediateMode(resultProcessList, cpuBox, ioBox, readyQueue) {
                this.resultTable.render(resultProcessList, cpuBox, ioBox, readyQueue, this.timelineLength);
                this.statisticTable.render(resultProcessList)
            }

            renderResultPlayingMode(resultPList, cpuBox, ioBox, readyQueue) {
                Helper.toggleControlBar(false);
                this.isRendering = true;

                // render result table
                this.renderResultTableInterval = setInterval(() => {
                    this.resultTable.render(resultPList, cpuBox, ioBox, readyQueue, this.timelineLength, this.resultTableMaxTime);

                    // scroll to current running cell
                    this.scrollToCurrentRunningCell()

                    if (this.resultTableMaxTime == cpuBox.length) this.onRenderResultFinish(resultPList);
                    this.resultTableMaxTime++;
                }, ResultBox.renderingGapTime);
            }

            onRenderResultFinish(resultPList) {
                clearInterval(this.renderResultTableInterval)
                Helper.toggleControlBar(true);
                this.resultTableMaxTime = 0;
                this.timelineLength = 0;
                this.isRendering = false;
                this.statisticTable.render(resultPList);
            }

            scrollToCurrentRunningCell() {
                const runningCell = document.querySelector('table#result-table tbody td:last-child');
                const halfClientBoxWidth = domEle.resultBox.clientWidth / 2;
                const leftOffset = runningCell.offsetLeft - halfClientBoxWidth;
                if (leftOffset > 0) Helper.scrollHorizontal(domEle.resultBox, leftOffset)
            }

            static clearTables() {
                domEle.resultTableArea.innerHTML = '';
                domEle.statisticTableArea.innerHTML = '';
            }

            static clear() {
                ResultBox.clearTables();
                domEle.algorithmHeading.innerHTML = '';
            }
        }

        class ResultTable {
            timelineLength = 0;
            maxTime = 0;
            isRendering = false;

            constructor() {
            }

            render(resultProcessList, cpuBox, ioBox, readyQueue, timelineLength, maxTime = -1) {
                this.maxTime = maxTime;
                this.timelineLength = timelineLength;
                domEle.resultTableArea.innerHTML = this.getResultTableHtml(resultProcessList, cpuBox, ioBox, readyQueue, maxTime);
            }

            getResultTableHtml(resultProcessList, cpuBox, ioBox, readyQueue, maxTime = -1) {
                let html = `
        <table id="result-table" class="table">
            ${this.getResultTableTHeadHtml(cpuBox.length)}
            ${this.getResultTableTBodyHtml(resultProcessList, cpuBox, ioBox, readyQueue, maxTime)}
        </table>`;
                return html;
            }

            getResultTableTHeadHtml(length) {
                let thHtml = '';
                for (let i = 0; i < length; i++) thHtml += `<th>${i}</th>`;
                return `
        <thead>
            <tr>
                <th class="level-thead"></th>
                <th class="process-thead">Process</th>
                ${thHtml}
            </tr>
        </thead> `;

            }

            getResultTableTBodyHtml(pList, cpuBox, ioBox, readyQueue, maxTime = -1) {
                const pColor = {};

                // assign background color for each process
                pList.list.forEach((p, index) => {
                    const colorIndex = (index < Data.colors.length) ? index : index % Data.colors.length;
                    pColor[p.name] = Data.colors[colorIndex]
                })

                if (maxTime > -1) {
                    cpuBox = cpuBox.slice(0, maxTime);
                    ioBox = ioBox.slice(0, maxTime);
                    readyQueue = readyQueue.slice(0, maxTime);
                }
                let cpuLevelHtml = this.getCpuLevelHtml(pList, cpuBox, pColor);
                let ioLevelHtml = this.getIoLevelHtml(pList, ioBox, pColor);
                let readyQueueHtml = this.getReadyQueueHtml(pList, readyQueue);
                const tBodyHtml = `${cpuLevelHtml}${ioLevelHtml}${readyQueueHtml}`
                return tBodyHtml;
            }

            getCpuLevelHtml(pList, cpuBox, pColor) {
                let cpuTrArr = pList.list.map((p, index) => {
                    let trHtml = '';
                    let tdArr = cpuBox.map((pName, subIndex) => {
                        return this.drawTableCell('cpu', pName == p.name, cpuBox[subIndex - 1] != pName, p, pColor, subIndex, pName == null, cpuBox[subIndex - 1], cpuBox[subIndex + 1]);
                    })
                    let tdHtml = Helper.convertArrayToString(tdArr);

                    if (index == 0) {
                        // first row
                        trHtml = `
                <tr class="level-row">
                    <th class="level-name-cell" scope="row" rowspan="${pList.list.length}">CPU</th>
                    <td class="process-name">${p.name}</td>
                    ${tdHtml}
                </tr> `;
                    } else {
                        trHtml = `
                <tr>
                    <td class="process-name">${p.name}</td>
                    ${tdHtml}
                </tr> `;
                    }
                    return trHtml;
                })
                const html = Helper.addSpacing(Helper.convertArrayToString(cpuTrArr));
                return html;
            }

            getIoLevelHtml(pList, ioBox, pColor) {
                let trArr = pList.list.map((p, index) => {
                    let trHtml = '';
                    let tdArr = ioBox.map((pNames, subIndex) => {
                        const previousIo = ioBox[subIndex - 1] || [];
                        return this.drawTableCell('io', pNames.includes(p.name), !previousIo.includes(p.name), p, pColor, subIndex);
                    })
                    let tdHtml = Helper.convertArrayToString(tdArr);
                    if (index == 0) {
                        trHtml = `
                <tr class="level-row">
                    <th class="level-name-cell" scope="row" rowspan="${pList.list.length}">IO</th>
                    <td class="process-name">${p.name}</td>
                    ${tdHtml}
                </tr> `;
                    } else {
                        trHtml = `
                <tr>
                    <td class="process-name">${p.name}</td>
                    ${tdHtml}
                </tr> `;
                    }
                    return trHtml;
                })
                const html = Helper.addSpacing(Helper.convertArrayToString(trArr));
                return html;
            }

            drawTableCell(level, isCurrent, showLabel, rowP, pColor, time = null, isEmpty = false, prevPname = null, nextPname = null) {
                let content = (showLabel && isCurrent) ? rowP.name : '';
                let htmlClass = this.getTableCellHtmlClasses(level, time, time == rowP.arrival, showLabel, isCurrent, isEmpty, pColor[rowP.name], this.isWaitingForCpu(time, rowP.cpuRequestHistories), prevPname, nextPname)
                return `<td class="${htmlClass}">${content}</td> `;
            }

            getTableCellHtmlClasses(level, time, isArrival, isShowLabel, isHoldingCpu, isEmpty, color, isWaitingForCpu, prevPname, nextPname) {
                let htmlClass = (isEmpty) ? this.getEmptyLevelClass(prevPname, nextPname) : '';
                if (isHoldingCpu) {
                    htmlClass = `bg-${color}`;
                    if (isShowLabel) htmlClass += ' process-label ';
                } else if (level == 'cpu') {
                    if (isArrival) htmlClass += ` border-dashes-left-${color}`;
                    if (isWaitingForCpu) htmlClass += ` border-dashes-bottom-${color}`;
                }
                htmlClass += this.getHtmlHighlightClassIfPassCondition(time);
                return htmlClass;
            }

            getHtmlHighlightClassIfPassCondition(time) {
                const htmlClass = (time == this.maxTime - 1 && time < this.timelineLength - 1) ? ' border-solid-right-highlight' : '';
                return htmlClass;
            }

            isWaitingForCpu(time, cpuRequestHistories) {
                for (let i = 0; i < cpuRequestHistories.length; i++) {
                    let item = cpuRequestHistories[i];
                    if (time >= item[0] && time < item[1]) return true;
                }
                return false;
            }

            getEmptyLevelClass(prev, next) {
                let pos = '';
                if (!prev && !next) return '';
                else {
                    if (prev && next) pos = 'vertical';
                    else pos = (!prev) ? 'right' : 'left';
                }
                return `${pos}-dashes-border`;
            }

            getReadyQueueHtml(pList, readyQueue) {
                // create 3 row
                let trHtml = '';
                let tdArr = readyQueue.map((subQueue, subIndex) => {
                    let queueTdHtml = '';
                    for (let i = 0; i < pList.list.length; i++) {
                        const value = subQueue[i] || '';
                        queueTdHtml += `<tr><td >${value}</td></tr>`;
                    }
                    let queueTrHtml = `<table>${queueTdHtml}</table>`;
                    const htmlClass = this.getHtmlHighlightClassIfPassCondition(subIndex)
                    return `<td  class="${htmlClass}">${queueTrHtml}</td> `;
                })
                let tdHtml = Helper.convertArrayToString(tdArr);
                trHtml = `
            <tr id="ready-queue" class="level-row">
                <th   class="level-name-cell" scope="row" rowspan="${pList.list.length}">Ready Queue</th>
                <td></td>
                ${tdHtml}
            </tr> `;
                return trHtml;
            }


        }

        class StatisticTable {
            constructor() {
            }

            render(resultProcessList) {
                domEle.statisticTableArea.innerHTML = this.getStatisticTableHtml(resultProcessList);
            }

            getStatisticTableHtml(resultProcessList) {
                let html = `
        <table id="statistic-table" class="table">
            ${this.getStatisticTableTHeadHtml()}
            ${this.getStatisticTableTBodyHtml(resultProcessList)}
        </table>`;
                return html;
            }

            getStatisticTableTHeadHtml() {
                return `
        <thead>
            <tr>
                <th>Process</th>
                <th>R</th>
                <th>W</th>
                <th>T</th>
            </tr>
        </thead> `;
            }
            getStatisticTableTBodyHtml(pList) {
                return `
        <tbody>
            ${this.getStatisticDataRows(pList)}
            ${this.getStatisticAverageRow(pList)}
        </tbody>
          `;
            }

            getStatisticDataRows(pList) {
                const trArr = pList.list.map((p) => {
                    return `
            <tr>
                <td>${p.name}</td>
                <td>${p.responseTime}</td>
                <td>${p.waitingTime}</td>
                <td>${p.turnAroundTime}</td>
            </tr> `;
                })
                return Helper.convertArrayToString(trArr);
            }

            getStatisticAverageRow(pList) {
                const formatNumber = (val) => {
                    return val.toFixed(2)
                }
                let html = `
        <tr>
            <th>Average</th>
            <td>${formatNumber(pList.avgResponseTime)}</td>
            <td>${formatNumber(pList.avgWaitingTime)}</td>
            <td>${formatNumber(pList.avgTurnAroundTime)}</td>
        </tr> `;
                return html
            }

        }

        class Helper {
            static addSpacing(value, n = 1) {
                const html = `${value}${'<tr ><td colspan="1000"><br/></td></tr><tr class="tr-spacing"><td colspan="1000"><br/></td></tr>'.repeat(n)}`
                return html;
            }

            static convertArrayToString(array) {
                let str = array.reduce((prev, current) => {
                    return prev + current;
                }, '');
                return str;
            }

            static scrollHorizontal(element, offset) {
                setTimeout(() => {
                    // scroll to the end
                    element.scrollLeft = offset;
                }, ResultBox.renderingGapTime);
            }

            static scrollToBottom() {
                setTimeout(() => {
                    window.scrollTo(0, document.body.scrollHeight);
                }, ResultBox.renderingGapTime);
            }

            static toggleControlBar(value) {
                domEle.controlBarButtons.forEach(item => {
                    if (!value) item.setAttribute('disabled', 'disabled');
                    else item.removeAttribute('disabled');
                })
            }
        }

        new Main().run();
        function Main() {

            // initiate values
            this.formTable = new FormTable();
            this.processList = new ProcessList(new Data().defaultProcessArr);
            this.algorithmName = 'fcfs';
            this.quantum = 2;

            // MAIN CODE HERE =============
            this.run = function () {
                this.formTable.render(this.processList);
                this.setupControlEvents();
                this.setupFormEvents();

                document.getElementById(`${ResultBox.renderingMode}`).checked = true;
            }

            // ALGORITHM
            this.runAlgorithm = function () {
                const algorithm = new Algorithm(this.processList, this.algorithmName, this.quantum);
                const [pList, cpuBox, ioBox, readyQueue] = algorithm.run();
                const resultBox = new ResultBox();
                resultBox.render(pList, cpuBox, ioBox, readyQueue, this.algorithmName, this.quantum);
            }

            // SETUP
            this.setupControlEvents = function () {
                // add process btn click
                domEle.addProcessBtn.addEventListener('click', () => {
                    this.processList.addNewProcess();
                    this.formTable.render(this.processList);
                })

                // add cpu btn click
                domEle.requestBtn.addEventListener('click', () => {
                    this.processList.addNewRequest();
                    this.formTable.render(this.processList);
                })
                domEle.resetBtn.addEventListener('click', () => {
                    ResultBox.clear();
                    domEle.errorMessageArea.innerHTML = '';
                    this.processList = new ProcessList(new Data().defaultProcessArr);
                    this.formTable.render(this.processList);
                })
            }

            this.setupFormEvents = function () {
                domEle.inputTableForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    // rendering mode
                    const formData = new FormData(domEle.optionForm)
                    ResultBox.renderingMode = formData.get('rendering-mode');

                    //
                    const errMessage = this.processList.getError();
                    if (!errMessage) {
                        // clear error message
                        domEle.errorMessageArea.innerHTML = '';

                        // run algorithm
                        this.runAlgorithm();
                    }
                    else {
                        // show error message
                        domEle.errorMessageArea.innerHTML = `<h3>${errMessage}</h3>`;
                    }
                })

                domEle.algorithmSelect.addEventListener('change', (e) => {
                    this.algorithmName = e.target.value;
                    this.renderOption();
                })
                domEle.quantumInput.addEventListener('change', (e) => {
                    this.quantum = e.target.value;
                })

                this.renderOption();
            }

            this.renderOption = function () {
                domEle.algorithmSelect.value = this.algorithmName;
                let quantumDisplayVal = (this.algorithmName === 'rr') ? 'block' : 'none';
                domEle.quantumContainer.style.display = quantumDisplayVal;
                domEle.quantumInput.value = this.quantum;
            }

        }

    </script>
</body>

</html>